<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="环境macOS 10.15.5python 3.7 问题说明文本行分割是OCR的一个重要问题，一般来说大部分英文的手写识别模型（HTR）都是根据行（或每个词）识别文本，因此有必要在数据处理阶段将文本图像分割成行。 解决方案打印文本的行分割由于一般的打印文本格式工整且不涉及文本重叠，因此只需要将图像进行简单的形态学操作即可： 1234567891011121314151617181920212223">
<meta property="og:type" content="article">
<meta property="og:title" content="使用OpenCV进行文本图像行分割">
<meta property="og:url" content="http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/index.html">
<meta property="og:site_name" content="blackdogtop">
<meta property="og:description" content="环境macOS 10.15.5python 3.7 问题说明文本行分割是OCR的一个重要问题，一般来说大部分英文的手写识别模型（HTR）都是根据行（或每个词）识别文本，因此有必要在数据处理阶段将文本图像分割成行。 解决方案打印文本的行分割由于一般的打印文本格式工整且不涉及文本重叠，因此只需要将图像进行简单的形态学操作即可： 1234567891011121314151617181920212223">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/OpenCV%20Tutorials.png">
<meta property="og:image" content="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/OpenCV%20Tutorials%20line%20segment.png">
<meta property="og:image" content="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/goat-overlap-line.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/goat-connected-component.jpg">
<meta property="og:image" content="https://i.stack.imgur.com/TJgbJ.png">
<meta property="article:published_time" content="2020-07-02T02:37:50.000Z">
<meta property="article:modified_time" content="2020-12-04T06:53:13.662Z">
<meta property="article:author" content="blackdogtop">
<meta property="article:tag" content="计算机视觉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/OpenCV%20Tutorials.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/blackcat.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/android-chrome-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>使用OpenCV进行文本图像行分割</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects/">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/09/01/2020%E5%B9%B49%E6%9C%88%E5%A6%82%E4%BD%95%E9%80%89%E8%B4%AD75%E8%8B%B1%E5%AF%B8%E7%94%B5%E8%A7%86/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/05/30/Genetic-Programming/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&text=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&is_video=false&description=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=使用OpenCV进行文本图像行分割&body=Check out this article: http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&name=使用OpenCV进行文本图像行分割&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&t=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#环境"><span class="toc-number">1.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题说明"><span class="toc-number">2.</span> <span class="toc-text">问题说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案"><span class="toc-number">3.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打印文本的行分割"><span class="toc-number">3.1.</span> <span class="toc-text">打印文本的行分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写文本的行分割"><span class="toc-number">3.2.</span> <span class="toc-text">手写文本的行分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大致思路"><span class="toc-number">3.2.1.</span> <span class="toc-text">大致思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">3.2.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#灰度和二值化"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">灰度和二值化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#形态学操作"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">形态学操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#行文本主体轮廓"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">行文本主体轮廓</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ROI-region-of-interest-设定"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">ROI(region of interest)设定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#连通区域寻找"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">连通区域寻找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文本连通区域获取"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">文本连通区域获取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连通区域轮廓"><span class="toc-number">3.2.3.</span> <span class="toc-text">连通区域轮廓</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总体代码"><span class="toc-number">4.</span> <span class="toc-text">总体代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        使用OpenCV进行文本图像行分割
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">blackdogtop</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-07-02T02:37:50.000Z" itemprop="datePublished">2020-07-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag">计算机视觉</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>macOS 10.15.5<br>python 3.7</p>
<h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>文本行分割是OCR的一个重要问题，一般来说大部分英文的手写识别模型（HTR）都是根据行（或每个词）识别文本，因此有必要在数据处理阶段将文本图像分割成行。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="打印文本的行分割"><a href="#打印文本的行分割" class="headerlink" title="打印文本的行分割"></a>打印文本的行分割</h3><p>由于一般的打印文本格式工整且不涉及文本重叠，因此只需要将图像进行简单的形态学操作即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">file &#x3D; &#39;&#x2F;Users&#x2F;zzmacbookpro&#x2F;PycharmProjects&#x2F;test&#x2F;OpenCV Tutorials.png&#39;</span><br><span class="line">image &#x3D; cv2.imread(file)</span><br><span class="line"></span><br><span class="line"># 灰度</span><br><span class="line">gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"># 二值化</span><br><span class="line">ret, thresh &#x3D; cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)</span><br><span class="line"></span><br><span class="line"># 膨胀</span><br><span class="line">kernel &#x3D; np.ones((5, 100), np.uint8)</span><br><span class="line">img_dilation &#x3D; cv2.dilate(thresh, kernel, iterations&#x3D;1)</span><br><span class="line"></span><br><span class="line"># 寻找轮廓并排序</span><br><span class="line">ctrs, hier &#x3D; cv2.findContours(img_dilation.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">sorted_ctrs &#x3D; sorted(ctrs, key&#x3D;lambda ctr: cv2.boundingRect(ctr)[0])</span><br><span class="line">for i, ctr in enumerate(sorted_ctrs):</span><br><span class="line">    # 画矩形</span><br><span class="line">    x, y, w, h &#x3D; cv2.boundingRect(ctr)</span><br><span class="line">    cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2)</span><br><span class="line"></span><br><span class="line"># 显示图像</span><br><span class="line">cv2.imshow(&#39;marked areas&#39;, image)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>原图与最终得到的行分割图像如下：<br><img src="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/OpenCV%20Tutorials.png" alt="print-origin"><br><img src="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/OpenCV%20Tutorials%20line%20segment.png" alt="print-line-segment"></p>
<h3 id="手写文本的行分割"><a href="#手写文本的行分割" class="headerlink" title="手写文本的行分割"></a>手写文本的行分割</h3><p>相较于打印文本，手写文本的行分割要更困难，原因在于手写的文本经常有水平方向上的字符重叠（即图中橙线同时与上方文本的”g”和下方文本的”t”有接触）。<br><img src="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/goat-overlap-line.jpg" width="30%" height="30%"></p>
<h4 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h4><p>在上述的打印文本行分割的例子中，w行分割主要是依据对于横向膨胀的二值化图像寻找轮廓，但如果采用与之前同样的方法分割手写文本，则很可能由于膨胀操作导致二值化图像有重叠从而将多行文本错误的识别成单行。因此另一种思路如下图所示，即使用红色矩形框出主体文本，再用绿色矩形框出与主体文本的连通区域（为了方便阐释思路图中矩形均为手画）<br><img src="https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/goat-connected-component.jpg" width="30%" height="30%"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>这里我使用的数据集是British Geological Survey (BGS) borehole scanned records（<a href="https://mapapps.bgs.ac.uk/geologyofbritain/home.html" target="_blank" rel="noopener">mapapps</a> <a href="http://scans.bgs.ac.uk/sobi_scans/internal/boreholes/pages/1" target="_blank" rel="noopener">sobi_scans</a>）</p>
<h5 id="灰度和二值化"><a href="#灰度和二值化" class="headerlink" title="灰度和二值化"></a>灰度和二值化</h5><p>首先将图片灰度和二值化处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 灰度，二值化</span><br><span class="line">gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh &#x3D; cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>
<p>处理后的图像如下(这里我首先移除了水平线，竖直线和噪点，故图像看起来比较“干净”)<br><img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-binary.png" width="50%" height="50%"></p>
<h5 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h5><p>此处的形态学操作目的是方便找到每行文本的主体区域，在进行形态学操作时，需要尽可能对水平方向的像素进行操作，即<code>kernel = np.ones((a, b), np.uint8)</code>中的b，这里我进行了膨胀-腐蚀-膨胀的操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 膨胀-腐蚀-膨胀</span><br><span class="line">kernel &#x3D; np.ones((5, 20), np.uint8)</span><br><span class="line">img_dilation &#x3D; cv2.dilate(thresh, kernel, iterations&#x3D;1)</span><br><span class="line">kernel &#x3D; np.ones((7, 40), np.uint8)</span><br><span class="line">img_erode &#x3D; cv2.erode(img_dilation, kernel, iterations&#x3D;1)</span><br><span class="line">kernel &#x3D; np.ones((2, 70), np.uint8)</span><br><span class="line">img_dilation &#x3D; cv2.dilate(img_erode, kernel, iterations&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>首先的闭操作（先膨胀后腐蚀）填充行文本中小的区域，又在竖直方向上有轻微的腐蚀，使其明确行文本的主体区域。<br><img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-close.png" width="50%" height="50%"><br>再进行水平方向上的膨胀，处理后的图像如下<br><img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-dilate.png" width="50%" height="50%"></p>
<h5 id="行文本主体轮廓"><a href="#行文本主体轮廓" class="headerlink" title="行文本主体轮廓"></a>行文本主体轮廓</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 寻找主体轮廓并画出</span><br><span class="line">ctrs, hier &#x3D; cv2.findContours(img_dilation.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">sorted_ctrs &#x3D; sorted(ctrs, key&#x3D;lambda ctr: cv2.boundingRect(ctr)[0])</span><br><span class="line">for i, ctr in enumerate(sorted_ctrs):</span><br><span class="line">    area &#x3D; cv2.contourArea(ctr)</span><br><span class="line">    x, y, w, h &#x3D; cv2.boundingRect(ctr)</span><br><span class="line">    cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2)</span><br></pre></td></tr></table></figure>
<img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-main-contours.png" width="50%" height="50%">

<h5 id="ROI-region-of-interest-设定"><a href="#ROI-region-of-interest-设定" class="headerlink" title="ROI(region of interest)设定"></a>ROI(region of interest)设定</h5><p>至此，每行文本的主体轮廓已经画出，接下来只需要将每个轮廓的上下边界多取一些像素作为roi，再找到roi中的文本的连通区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 填充</span><br><span class="line">cv2.rectangle(original_cpy1, (x, y), (x + w, y + h), (0, 0, 0), -1)</span><br><span class="line"># 三元表达式防止越界</span><br><span class="line">y_minus, y_plus &#x3D; 15, 15  # 竖直方向上下各多提取15, 15个像素</span><br><span class="line">y1 &#x3D; (y - y_minus) if (y - y_minus) &gt; 0 else 0</span><br><span class="line">y2 &#x3D; (y + h + y_plus) if (y + h + y_plus) &lt; original_cpy1.shape[0] else original_cpy1.shape[0]</span><br><span class="line">roi &#x3D; original_cpy1[y1:y2, x:x + w]</span><br></pre></td></tr></table></figure>
<p>这里我首先将每个轮廓（红色矩形的位置）做了填充，会在稍后解释原因。<br>之后定义每个roi为每个红色矩形的位置向上向下各多提取15个像素，并使用三元表达式防止额外的区域超出了图片的最大或最小高度从而产生错误可能。</p>
<h5 id="连通区域寻找"><a href="#连通区域寻找" class="headerlink" title="连通区域寻找"></a>连通区域寻找</h5><p>OpenCV提供了<code>cv2.connectedComponents</code>方法来寻找连通区域，具体的效果如图<img src="https://i.stack.imgur.com/TJgbJ.png" alt="connectedComponents"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 灰度，二值化，连通区域</span><br><span class="line">gray &#x3D; cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)</span><br><span class="line">binary &#x3D; cv2.threshold(~gray, 127, 255, cv2.THRESH_BINARY)[1]</span><br><span class="line">ret, labels &#x3D; cv2.connectedComponents(binary)</span><br></pre></td></tr></table></figure>
<p>这里将roi灰度与二值化后获取其连通区域，connectedComponents的两个返回值ret和labels分别代表连通区域的总数与各个轮廓的x, y, width, height和面积</p>
<h5 id="文本连通区域获取"><a href="#文本连通区域获取" class="headerlink" title="文本连通区域获取"></a>文本连通区域获取</h5><p>以上获取了roi中所有的连通区域，接下来需要找到哪部分的连通区域是主体文本，由于二值化图像像素越“浅”其值接近255，即白色像素值为255，黑色像素值为0。所以我将上述的主体轮廓（红色矩形位置）进行填充，从而在获取文本连通区域时只需要寻找值最大的连通区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 找到像素值最大的connected component</span><br><span class="line">max_white_pixel &#x3D; 0</span><br><span class="line">for label in range(1, ret):</span><br><span class="line">    mask &#x3D; np.array(labels, dtype&#x3D;np.uint8)</span><br><span class="line">    mask[labels &#x3D;&#x3D; label] &#x3D; 255</span><br><span class="line">    mask_sum &#x3D; np.sum(mask)</span><br><span class="line">    if mask_sum &gt; max_white_pixel:</span><br><span class="line">        max_white_pixel &#x3D; mask_sum</span><br><span class="line">        max_pixel_index &#x3D; label  # 索引</span><br><span class="line">max_mask &#x3D; np.array(labels, dtype&#x3D;np.uint8)</span><br><span class="line">max_mask[labels &#x3D;&#x3D; max_pixel_index] &#x3D; 255</span><br></pre></td></tr></table></figure>
<p>图中白色部分即为获取到的最大连通区域<br><img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-max-connected-component.png" width="50%" height="50%"></p>
<h4 id="连通区域轮廓"><a href="#连通区域轮廓" class="headerlink" title="连通区域轮廓"></a>连通区域轮廓</h4><p>在获取到文本连通区域之后，只需要将原有的主体文本区域填充，并将剩余的部分用其他颜色矩形画出即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># convert to RGB</span><br><span class="line">max_mask &#x3D; cv2.cvtColor(max_mask, cv2.COLOR_GRAY2RGB)</span><br><span class="line"># 主体轮廓填充</span><br><span class="line">cv2.rectangle(max_mask, (0, y_minus), (0 + w, y_minus + h), (0, 0, 0), -1)</span><br><span class="line"># 转换灰度二值</span><br><span class="line">gray_mask &#x3D; cv2.cvtColor(max_mask, cv2.COLOR_BGR2GRAY)</span><br><span class="line">binary_mask &#x3D; cv2.threshold(gray_mask, 127, 255, cv2.THRESH_BINARY)[1]</span><br><span class="line"># 轮廓提取</span><br><span class="line">ctrs, hier &#x3D; cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">sorted_ctrs &#x3D; sorted(ctrs, key&#x3D;lambda ctr: cv2.boundingRect(ctr)[0])</span><br><span class="line">contours_coordinate_list &#x3D; []</span><br><span class="line">for i, ctr in enumerate(sorted_ctrs):</span><br><span class="line">    x_component, y_component, w_component, h_component &#x3D; cv2.boundingRect(ctr)</span><br><span class="line">    contours_coordinate_list.append([x_component, y_component, w_component, h_component])</span><br><span class="line">    cv2.rectangle(roi, (x_component, y_component), (x_component + w_component, y_component + h_component),</span><br><span class="line">                  (0, 255, 0), 1)</span><br></pre></td></tr></table></figure>
<p>最终效果如下所示，使用此方法仍有不足之处，就像图片部分文本行未被有效分割，此外此方法不具强鲁棒性，对于不同图片需要改变不同的形态学操作kernels。<br><img src = "https://raw.githubusercontent.com/blackdogtop/image-host/master/Personal%20Blog/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/14367_13377931-n-011-above-below-lines.png" width="80%" height="80%"></p>
<h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line">file &#x3D; &#39;without_noise.png&#39;</span><br><span class="line">image &#x3D; cv2.imread(file)</span><br><span class="line">img_cpy1 &#x3D; image.copy()</span><br><span class="line">img_cpy2 &#x3D; image.copy()</span><br><span class="line"></span><br><span class="line"># 灰度，二值化</span><br><span class="line">gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh &#x3D; cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)</span><br><span class="line"></span><br><span class="line"># 膨胀-腐蚀-膨胀</span><br><span class="line">kernel &#x3D; np.ones((5, 20), np.uint8)</span><br><span class="line">img_dilation &#x3D; cv2.dilate(thresh, kernel, iterations&#x3D;1)</span><br><span class="line">kernel &#x3D; np.ones((7, 40), np.uint8)</span><br><span class="line">img_erode &#x3D; cv2.erode(img_dilation, kernel, iterations&#x3D;1)</span><br><span class="line">kernel &#x3D; np.ones((2, 70), np.uint8)</span><br><span class="line">img_dilation &#x3D; cv2.dilate(img_erode, kernel, iterations&#x3D;1)</span><br><span class="line"></span><br><span class="line"># 寻找主体轮廓并画出</span><br><span class="line">ctrs, hier &#x3D; cv2.findContours(img_dilation.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">sorted_ctrs &#x3D; sorted(ctrs, key&#x3D;lambda ctr: cv2.boundingRect(ctr)[0])</span><br><span class="line">for i, ctr in enumerate(sorted_ctrs):</span><br><span class="line">    area &#x3D; cv2.contourArea(ctr)</span><br><span class="line">    x, y, w, h &#x3D; cv2.boundingRect(ctr)</span><br><span class="line">    cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2)</span><br><span class="line"></span><br><span class="line">    # 填充</span><br><span class="line">    cv2.rectangle(img_cpy1, (x, y), (x + w, y + h), (0, 0, 0), -1)</span><br><span class="line">    # 三元表达式防止越界</span><br><span class="line">    y_minus, y_plus &#x3D; 15, 15  # 竖直方向上下各多提取15, 15个像素</span><br><span class="line">    y1 &#x3D; (y - y_minus) if (y - y_minus) &gt; 0 else 0</span><br><span class="line">    y2 &#x3D; (y + h + y_plus) if (y + h + y_plus) &lt; img_cpy1.shape[0] else img_cpy1.shape[0]</span><br><span class="line">    roi &#x3D; img_cpy1[y1:y2, x:x + w]</span><br><span class="line"></span><br><span class="line">    # 灰度，二值化，连通区域</span><br><span class="line">    gray &#x3D; cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    binary &#x3D; cv2.threshold(~gray, 127, 255, cv2.THRESH_BINARY)[1]</span><br><span class="line">    ret, labels &#x3D; cv2.connectedComponents(binary)</span><br><span class="line"></span><br><span class="line">    # 找到像素值最大的connected component</span><br><span class="line">    max_white_pixel &#x3D; 0</span><br><span class="line">    for label in range(1, ret):</span><br><span class="line">        mask &#x3D; np.array(labels, dtype&#x3D;np.uint8)</span><br><span class="line">        mask[labels &#x3D;&#x3D; label] &#x3D; 255</span><br><span class="line">        mask_sum &#x3D; np.sum(mask)</span><br><span class="line">        if mask_sum &gt; max_white_pixel:</span><br><span class="line">            max_white_pixel &#x3D; mask_sum</span><br><span class="line">            max_pixel_index &#x3D; label  # 索引</span><br><span class="line">    max_mask &#x3D; np.array(labels, dtype&#x3D;np.uint8)</span><br><span class="line">    max_mask[labels &#x3D;&#x3D; max_pixel_index] &#x3D; 255</span><br><span class="line"></span><br><span class="line">    # convert to RGB</span><br><span class="line">    max_mask &#x3D; cv2.cvtColor(max_mask, cv2.COLOR_GRAY2RGB)</span><br><span class="line">    # 主体轮廓填充</span><br><span class="line">    cv2.rectangle(max_mask, (0, y_minus), (0 + w, y_minus + h), (0, 0, 0), -1)</span><br><span class="line">    # 转换灰度二值</span><br><span class="line">    gray_mask &#x3D; cv2.cvtColor(max_mask, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    binary_mask &#x3D; cv2.threshold(gray_mask, 127, 255, cv2.THRESH_BINARY)[1]</span><br><span class="line">    # 轮廓提取</span><br><span class="line">    ctrs, hier &#x3D; cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    sorted_ctrs &#x3D; sorted(ctrs, key&#x3D;lambda ctr: cv2.boundingRect(ctr)[0])</span><br><span class="line">    contours_coordinate_list &#x3D; []</span><br><span class="line">    for i, ctr in enumerate(sorted_ctrs):</span><br><span class="line">        x_component, y_component, w_component, h_component &#x3D; cv2.boundingRect(ctr)</span><br><span class="line">        contours_coordinate_list.append([x_component, y_component, w_component, h_component])</span><br><span class="line">        cv2.rectangle(image, (x + x_component, y1 + y_component), (x + x_component + w_component, y1 + y_component + h_component),</span><br><span class="line">                      (0, 255, 0), 1)</span><br><span class="line"></span><br><span class="line">    # 深拷贝以免填充的矩形影响识别</span><br><span class="line">    img_cpy1 &#x3D; copy.deepcopy(img_cpy2)</span><br><span class="line">    </span><br><span class="line">cv2.imshow(&#39;image&#39;, image)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/46282691/opencv-cropping-handwritten-lines-line-segmentation" target="_blank" rel="noopener">opencv - cropping handwritten lines (line segmentation)</a><br><a href="https://stackoverflow.com/questions/51523765/how-to-use-opencv-connectedcomponents-to-get-the-images" target="_blank" rel="noopener">How to use OpenCV ConnectedComponents to get the images</a><br><a href="https://blog.csdn.net/qq_30815237/article/details/86898686" target="_blank" rel="noopener">OpenCV3学习(9.2)连通域分析函数详解connectedComponents()和connectedComponentsWithStats()</a><br><a href="https://stackoverflow.com/questions/46441893/connected-component-labeling-in-python" target="_blank" rel="noopener">connected component labeling in python</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects/">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#环境"><span class="toc-number">1.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题说明"><span class="toc-number">2.</span> <span class="toc-text">问题说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案"><span class="toc-number">3.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打印文本的行分割"><span class="toc-number">3.1.</span> <span class="toc-text">打印文本的行分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写文本的行分割"><span class="toc-number">3.2.</span> <span class="toc-text">手写文本的行分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大致思路"><span class="toc-number">3.2.1.</span> <span class="toc-text">大致思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">3.2.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#灰度和二值化"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">灰度和二值化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#形态学操作"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">形态学操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#行文本主体轮廓"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">行文本主体轮廓</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ROI-region-of-interest-设定"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">ROI(region of interest)设定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#连通区域寻找"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">连通区域寻找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文本连通区域获取"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">文本连通区域获取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连通区域轮廓"><span class="toc-number">3.2.3.</span> <span class="toc-text">连通区域轮廓</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总体代码"><span class="toc-number">4.</span> <span class="toc-text">总体代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&text=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&is_video=false&description=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=使用OpenCV进行文本图像行分割&body=Check out this article: http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&title=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&name=使用OpenCV进行文本图像行分割&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://yoursite.com/2020/07/02/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%A1%8C%E5%88%86%E5%89%B2/&t=使用OpenCV进行文本图像行分割" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020
    blackdogtop
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects/">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-168807126-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
